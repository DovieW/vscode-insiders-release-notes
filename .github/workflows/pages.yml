name: Poll for new VS Code Insiders builds

on:
  workflow_dispatch:
  schedule:
    # Every 30 minutes (best-effort)
    - cron: "*/30 * * * *"

permissions:
  contents: read
  actions: write

concurrency:
  group: "insiders-poll"
  cancel-in-progress: false

jobs:
  poll:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: master

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20

      - name: Determine builds to process (max 3)
        id: builds
        env:
          INSIDERS_COMMITS_FEED: https://update.code.visualstudio.com/api/commits/insider
          # Gate generation so we only publish builds that are actually available for users to install.
          # This matches what shows up in VS Code Insiders "About" once you've upgraded.
          INSIDERS_LATEST_UPDATE_URL: https://update.code.visualstudio.com/api/update/win32-x64-user/insider/latest
        run: |
          node - <<'NODE'
          const fs = require('fs');

          const feed = process.env.INSIDERS_COMMITS_FEED;
          const latestUpdateUrl = process.env.INSIDERS_LATEST_UPDATE_URL;
          async function main() {
            const state = JSON.parse(fs.readFileSync('data/insiders-state.json', 'utf8'));
            const last = state.lastProcessedBuildSha;

            const res = await fetch(feed, { headers: { 'User-Agent': 'insiders-changes-site' } });
            if (!res.ok) throw new Error(`Failed to fetch insiders commits feed: ${res.status} ${res.statusText}`);
            const commits = await res.json();
            if (!Array.isArray(commits) || commits.length === 0) throw new Error('Empty insiders commits feed');

            // Determine which build is actually available to users right now.
            // The update endpoint returns a JSON object whose `version` field is the commit SHA.
            let availableSha = commits[0];
            let availableIdx = 0;
            if (latestUpdateUrl) {
              const ures = await fetch(latestUpdateUrl, { headers: { 'User-Agent': 'insiders-changes-site' } });
              if (!ures.ok) throw new Error(`Failed to fetch latest update JSON: ${ures.status} ${ures.statusText}`);
              const latest = await ures.json();
              if (latest && typeof latest.version === 'string') {
                availableSha = latest.version;
                const idx = commits.indexOf(availableSha);
                if (idx !== -1) {
                  availableIdx = idx;
                } else {
                  console.warn(`Latest update SHA ${availableSha.slice(0,7)} not found in commits feed; falling back to feed head.`);
                  availableSha = commits[0];
                  availableIdx = 0;
                }
              }
            }

            // Only consider the subset of commits that are <= latest available build.
            // commits[0..availableIdx-1] are newer than what's available and should be ignored.
            const availableCommits = commits.slice(availableIdx);

            let builds = [];
            if (!last) {
              builds = [availableCommits[0]]; // bootstrap: generate latest available build
            } else {
              const idx = availableCommits.indexOf(last);
              if (idx === -1) {
                // If we've somehow processed a build newer than what's currently available, do nothing.
                const globalIdx = commits.indexOf(last);
                if (globalIdx !== -1 && globalIdx < availableIdx) {
                  builds = [];
                } else {
                  builds = [availableCommits[0]];
                }
              } else {
                const unprocessedNewer = availableCommits.slice(0, idx); // newest-first
                builds = unprocessedNewer.reverse().slice(0, 3); // oldest-first, cap 3
              }
            }

            const out = builds.filter(Boolean);
            console.log(`Found ${out.length} build(s) to process.`);
            console.log(`Latest available build: ${availableSha} (feed index ${availableIdx}).`);
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `builds=${JSON.stringify(out)}\n`);
          }

          main().catch((err) => {
            console.error(err);
            process.exit(1);
          });
          NODE

      - name: Dispatch build workflow
        if: ${{ steps.builds.outputs.builds != '[]' }}
        env:
          GH_REPO: ${{ github.repository }}
          GH_TOKEN: ${{ github.token }}
          BUILDS: ${{ steps.builds.outputs.builds }}
        run: |
          node - <<'NODE'
          const builds = JSON.parse(process.env.BUILDS || '[]');
          if (!builds.length) {
            console.log('No builds to dispatch.');
            process.exit(0);
          }

          async function dispatch(buildSha) {
            const url = `https://api.github.com/repos/${process.env.GH_REPO}/actions/workflows/build.yml/dispatches`;
            const res = await fetch(url, {
              method: 'POST',
              headers: {
                'Accept': 'application/vnd.github+json',
                'Authorization': `Bearer ${process.env.GH_TOKEN}`,
                'X-GitHub-Api-Version': '2022-11-28',
              },
              body: JSON.stringify({
                ref: 'master',
                inputs: { buildSha },
              }),
            });

            if (!res.ok) {
              const text = await res.text();
              throw new Error(`Dispatch failed for ${buildSha}: ${res.status} ${res.statusText} ${text}`);
            }
          }

          (async () => {
            for (const sha of builds) {
              console.log(`Dispatching build workflow for ${sha}...`);
              await dispatch(sha);
            }
          })().catch((err) => {
            console.error(err);
            process.exit(1);
          });
          NODE
